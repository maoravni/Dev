/*****************************************************************************
 * File Name: Temperature_Module_Handler.c
 *
 * Version: 02.02
 *
 * Description:
 *   The file is divided in 2:
 *   1. PT100 Inputs which responsible for:
 *      a. The MUXing of the voltages across 4 PT100's and 1 calibration resistor when
 *         current is flowing through them and when not. the "non-current" voltages are used
 *         for 1/f noise reduction.
 *      b. Conversion of measured voltage to temperature.
 *   2. PWM outputs with controllable duty cycle.
 *
 * Note:
 *   the PWM outputs are hard ANDed with the Safet_Relay input.
 *
 ********************************************************************************/

/***************************************
 * Includes
 ***************************************/
#include "Temperature_Module_Handler.h"
#include "Digital_IO_Module_Handler.h"
#include "Communications_Handler.h"
#include "System_Handler.h"
#include "main.h"
#include "DSP.h"
#include <string.h>
#include <otsm.h>

/***************************************
 *    Global Variables
 ***************************************/
/* Variable declarations for DMA . 
 * These variables are defined as global variables to avoid "may be used before being set" warning
 * issued by the PSoC 5 compilers  MDK/RVDS.In this case these variables are automatically initialized to zero */

uint8 DSM_DMA_Chan;
uint8 DSM_DMADone_flag;
uint8 DSMDataWriteEnable;

uint8 CalcTempr_InitVar;
uint8 WarnBitfield[4] =
{ 0x02, 0x08, 0x20, 0x80 };
uint8 ErrorBitfield[4] =
{ 0x01, 0x04, 0x10, 0x40 };
uint8 Ind2Bit_5[5] =
{ 0x01, 0x02, 0x04, 0x08, 0x10 };

/// bitmask intdicating if this RTD is required for normal operation. Index 0 means calibration resistor.
uint8 RequiredRTDsBitfield;
/// bitmask indicating if this RTD is connected. Index 0 means calibration resistor.
uint8 ConnectedRTDsBitfield;

float TempUpLimit[NUM_OF_TEMP_SENS] =
{ 0, 0, 0, 0 };

uint16 Temperature1_Monitor;
uint16 Temperature2_Monitor;
uint16 Temperature3_Monitor;
uint16 Temperature4_Monitor;

int16 DSM_Sample[NUM_OF_DSM_SAMPLES] =
{ 0 };
int16 DSM_SampleLatch[NUM_OF_DSM_SAMPLES] =
{ 0 };

uint8 Initiate_PID_Flag, Enable_PID;

int8 No_Liquid_Timer[NUM_OF_TEMP_SENS];
uint8 LiquidDetectorTimeOut[NUM_OF_TEMP_SENS];

T_StoredTemps4MMCU StoredTemps4MMCU;
T_RTD_Configuration RTD_Configuration;

/*******************************************************************************
 ********************  P T 1 0 0    I N P T S   *********************************
 ********************************************************************************/

/*******************************************************************************
 * Function Name:  Init_Temperature_Module
 ********************************************************************************
 *
 * Summary:
 *    InitTempSense initiate the RTD temperature sensing modules and system.
 *
 * Parameters:
 *   None.
 *
 * Return:
 *   None.
 *******************************************************************************/
void Init_Temperature_Module(void)
{
    uint8 i;
    /* raise a flag to initiate the temperature calculation arrays */
    CalcTempr_InitVar = 0;
    /* Start the current source for RTD's excitement */
    IDAC_Start();
    /* Start the DSM Sequencer */
    DSM_Sequencer_Start();
    /* Delay between Mux switch and SOC */
    DSM_Sequencer_SOC_Delay_SetPeriod(199);
    /* Start the Delta Sigma Modulation (DSM) ADC for the RTD's Measurements */
    DSM_Start();
    /* Disable the ADC ISR as it is not required */
    DSM_IRQ_Disable();
    /* Start the DMA Interrupt module */
    ISR_DSM_DMA_Start();
    /* Relocate the ISRs of the Temperature Module */
    Temperature_ISRs_Relocate();
    /* Initiate the DMA module */
    DSM_DMA_Config();
    /* Lower the  DMADone flag */
    DSM_DMADone_flag = 0;
    /*Initiate RequiredRTDsBitfield */
    RequiredRTDsBitfield = 0x01;
    OTSM_ResetSensorPriority();
    ConnectedRTDsBitfield = 0x00;
    RTD_Configuration.ChannelType = E_PT100;

    /*Initiate Temperature reading */
    memset(StoredTemps4MMCU.temperature, 0, sizeof(StoredTemps4MMCU.temperature));
    StoredTemps4MMCU.statusBits = 0;
    /* initiate PID */
    Enable_PID = 0;
    Initiate_PID_Flag = 1;
    /* initiate liquid detection time outs */
    for (i = 0; i < NUM_OF_TEMP_SENS; i++)
    {
        LiquidDetectorTimeOut[i] = 1;
        No_Liquid_Timer[i] = 0;
    }
    ApplicatorDripValveEnable = FALSE;
    /* Allow writing data into DSM_SampleLatch */
    DSMDataWriteEnable = 1;
}

/*******************************************************************************
 * Function Name:  DSM_DMA_Config
 ********************************************************************************
 *
 * Summary:
 *    Code generated by the DMA Wizard.
 *
 *   DMA_Config() performs following functions:
 *  1: Initializes the DMA channel
 *  2: Allocates TraCH0_ERRORnsfer Descriptors
 *  3: Configures the TD.
 *  4: Sets source and destination address for this TD.
 *  5: Initializes the TD.
 *  6: Enables the DMA channel.
 *
 * Parameters:
 *  None.
 *
 * Return:
 *  None.
 *
 *******************************************************************************/
void DSM_DMA_Config()
{
    uint8 DSM_DMA_TD[1];
    /* DMA Initialization - 2 byte per trigger.Each burst transfer needs a new request. 
     * Set upper source and destination address. */
    DSM_DMA_Chan = DSM_DMA_DmaInitialize(DSM_DMA_BYTES_PER_BURST, DSM_DMA_REQUEST_PER_BURST, HI16(DSM_DMA_SRC_BASE),
            HI16(DSM_DMA_DST_BASE));
    /* Allocate TD */
    DSM_DMA_TD[0] = CyDmaTdAllocate();
    /* Destination address is incremented after each transaction and Term out generated after 
     * the specified no. of bytes are transferred to memory
     * Transfer the specified number of samples and generate term out */
    CyDmaTdSetConfiguration(DSM_DMA_TD[0], (sizeof(DSM_Sample)), DSM_DMA_TD[0],
            DSM_DMA__TD_TERMOUT_EN | TD_INC_DST_ADR);

    /* Set source and destination address */
    CyDmaTdSetAddress(DSM_DMA_TD[0], LO16((uint32 ) DSM_DEC_SAMP_PTR), LO16((uint32 ) DSM_Sample));
    /* Set the initial TD for the channel */
    CyDmaChSetInitialTd(DSM_DMA_Chan, DSM_DMA_TD[0]);
    /* Enable the DMA channel */
    CyDmaChEnable(DSM_DMA_Chan, 1);
}

/***********************************
 * Function Name:  Calc_Temperature
 ************************************
 *
 * Summary:
 *   Calc_Temperature will measure the temperatures with the RTS sensors
 *
 * Remarks:
 *   See "Temp_Sense_Handler.h" for algorithm details.
 *
 * Parameters:
 *   none.
 *
 * Return:
 *   none.
 *
 *******************************************************************************/
void Calc_Temperature(void)
{
    static int32 FiltNoOffset_DSM_Sample[NUM_OF_TEMP_SENS + 1][2];
    static int32 NoOffset_DSM_Sample[NUM_OF_TEMP_SENS + 1];
    static int16 Quik_NoOffset_DSM_Sample[NUM_OF_TEMP_SENS + 1];
    static int16 NoOffset_DSM_Sample_Buffer[(NUM_OF_TEMP_SENS + 1)][(TEMPTR_MED_FILT_WIDTH)];
    // maor: This seems like it's not required at the moment:
    static uint8 LPF_SettleTimeCounter;
    static uint8 n = 1;
    static uint8 MedIndx = TEMPTR_MED_FILT_WIDTH;
    int16 Temp_NoOffset_DSM_Sample[TEMPTR_MED_FILT_WIDTH];
    memset(Temp_NoOffset_DSM_Sample, 0, sizeof(Temp_NoOffset_DSM_Sample));
    uint8 i;

    uint8 DSM_Samle_Indx_Pair;
    DSM_Samle_Indx_Pair = 0;

    float RTD_Resistance;

    if (!CalcTempr_InitVar)
    {
        CalcTempr_InitVar++;
        memset(FiltNoOffset_DSM_Sample, 0, sizeof(FiltNoOffset_DSM_Sample));
        memset(NoOffset_DSM_Sample, 0, sizeof(NoOffset_DSM_Sample));
        memset(Quik_NoOffset_DSM_Sample, 0, sizeof(Quik_NoOffset_DSM_Sample));
        memset(NoOffset_DSM_Sample_Buffer, 0, sizeof(NoOffset_DSM_Sample_Buffer));
        LPF_SettleTimeCounter = 255;
        MedIndx = TEMPTR_MED_FILT_WIDTH;
    }

    /* Quick Data acquire */
    //////////////////////
    /* Disable the write to DSM_SampleLatch */
    DSMDataWriteEnable = 0;

    /* Start of 1/f Noise reduction */
    for (i = 0; i < NUM_OF_TEMP_SENS + 1; i++)
    {
        Quik_NoOffset_DSM_Sample[i] = (DSM_SampleLatch[DSM_Samle_Indx_Pair + 1] - DSM_SampleLatch[DSM_Samle_Indx_Pair]);
        /* increase the DSM_SampleLatch index pair */
        DSM_Samle_Indx_Pair += 2;
        /* End of 1/f Noise reduction */
    }
    /* Enable the write to DSM_SampleLatch */
    DSMDataWriteEnable = 1;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /* increasing the index for median filter for all channels together */
    MedIndx = CYC_INC_INDX(MedIndx, TEMPTR_MED_FILT_WIDTH);
    /* DSM DSP for calibrating resistor and all temperature sensor*/
    for (i = 0; i < NUM_OF_TEMP_SENS + 1; i++)
    {
        /* If System configuration do need this sensor */
        //----------------------------------------------------------------------------------------------------------------------
        /* Fill Median filter buffer */
        NoOffset_DSM_Sample_Buffer[i][MedIndx] = Quik_NoOffset_DSM_Sample[i];
        // Create a copy of the buffer
        memcpy(Temp_NoOffset_DSM_Sample, &NoOffset_DSM_Sample_Buffer[i][0], sizeof(Temp_NoOffset_DSM_Sample));

        // sort the copy of the median filter buffer and determine it's median value.
        NoOffset_DSM_Sample[i] = ((int32) Med_Filter(Temp_NoOffset_DSM_Sample, TEMPTR_MED_FILT_WIDTH))
                * PRECISION_MULTIPLIER;
        // Data is ready in NoOffset_DSM_Sample.
        /* End of Median filter */
        //----------------------------------------------------------------------------------------------------------------------
        //----------------------------------------------------------------------------------------------------------------------
        /* Start of Single Pole IIR low-pass filtering the NoOffset_DSM_Sample */
        if (RTD_Configuration.ChannelType == E_Liquid_Detector)
        {
            FiltNoOffset_DSM_Sample[i][n] = IIR_LPF_sp(NoOffset_DSM_Sample[i], &FiltNoOffset_DSM_Sample[i][n - 1],
            LIQUID_DETECT_FILT_NUME);
        }
        else
        {
            FiltNoOffset_DSM_Sample[i][n] = IIR_LPF_sp(NoOffset_DSM_Sample[i], &FiltNoOffset_DSM_Sample[i][n - 1],
            TEMP_FILT_NUME);
        }
        /* End of IIR_LPF_sp */

        /* Start of Connectivity verification */
        //////////////////////////////////////////////////////////////////////////////////////////////////////
        /* Channel is not connected !!! */
        if (FiltNoOffset_DSM_Sample[i][n] < MIN_SAMPLES_OFFSET * PRECISION_MULTIPLIER) // Temperature Sensor Connection Failure !!!
        {
            if (LPF_SettleTimeCounter)
            {
                LPF_SettleTimeCounter--;
                /* Bypass the Connectivity check */
                if (RequiredRTDsBitfield & Ind2Bit_5[i])
                {
                    ConnectedRTDsBitfield |= Ind2Bit_5[i];
                }
            }
            else
            {
                // if not a calibration resistor Channel
                if (i)
                { // Write Warning
                    if (RTD_Configuration.ChannelType != E_Liquid_Detector)
                    {
                        StoredTemps4MMCU.statusBits |= WarnBitfield[(i - 1)];
                    }
                    ConnectedRTDsBitfield &= (~Ind2Bit_5[i]);
                    StoredTemps4MMCU.temperature[(i - 1)] = 0;
                }
                else
                {
                    // Set error for calibration resistor
                    SystemErrorReg_Write(RTD_CAL_RES_FAULT_ERR_BIT_NUM, ENABLE, _16BIT1);
                    ////////////////////////////////////////////
                    // TODO: Consider to open dry contact !!! //
                    ////////////////////////////////////////////
                }
            }
        }
        /* End of Connectivity verification */
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /* Channel is connected all right */
        else
        {
            /* Indicate that this channel is indeed connected */
            ConnectedRTDsBitfield |= Ind2Bit_5[i];
            // if not a calibration resistor Channel
            if (i)
            {
                // Reset Warning bit
                StoredTemps4MMCU.statusBits &= (~WarnBitfield[(i - 1)]);

                if (RTD_Configuration.ChannelType != E_Liquid_Detector)
                {
                    /* Start of temperatures calculation */
                    /*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
                    /*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
                    /*                            		 		D O   N O T   E D I T   T H O S E   L I N E S ! ! !                               	  */
                    /*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
                    /**/RTD_Resistance = (float) (FiltNoOffset_DSM_Sample[i][n] * CAL_REF_RESISTOR)
                            / FiltNoOffset_DSM_Sample[0][n]; /**/
                    /**/StoredTemps4MMCU.temperature[(i - 1)] = ((float) RTD_GetTemperature((RTD_Resistance * 1000)))
                            / 100.00 + TEMPERATURE_OFFSET; /**/
                    /*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/

                    uint8 TempError = OTSM_Check_Temperature(StoredTemps4MMCU.temperature[(i - 1)], (i - 1));
                    if (0x02 & TempError)
                    {
                        Safety_Relay_TurnON();
                        SystemErrorReg_Write(PSoC_RTD_OVER_TEMP_ERR_BIT_NUM, ENABLE, _16BIT2);
                        Outputs_SoftEn_OFF();
                    }
                    else if (0x01 & TempError)

                    {
                        /* Turn on PSOC_OVER_TEMP_ALARM */
                        SystemErrorReg_Write(PSoC_RTD_OVER_TEMP_ERR_BIT_NUM, ENABLE, _16BIT1);
                        Outputs_SoftEn_OFF();
                    }
                    /*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
                    /*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/

                    /* MMCU Temperature Error Check */
                    if ((StoredTemps4MMCU.temperature[(i - 1)] > (TempUpLimit[(i - 1)] + 0.3))
                            && (RequiredRTDsBitfield & Ind2Bit_5[i]))
                    {
                        /* Update system Errors */
                        SystemErrorReg_Write(MMCU_RTD_OVER_TEMP_ERR_BIT_NUM, ENABLE, _16BIT1);
                        StoredTemps4MMCU.statusBits |= ErrorBitfield[(i - 1)];
                    }
                    /* End of temperatures calculation  */
                }
            }
        }
        //----------------------------------------------------------------------------------------------------------------------=
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//        if (RequiredRTDsBitfield & Ind2Bit_5[i])
//        {
//        }
//        /* If System configuration do not need this sensor */
//        else
//        {
//            // Reset Temperature
//            StoredTemps4MMCU.temperature[(i - 1)] = 0;
//            // set the warning for that channel
//            if (i)
//            {
//                StoredTemps4MMCU.statusBits |= WarnBitfield[(i - 1)];
//            }
//        }
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /* If all the required channels are connected Enable the heating output */
    if (RTD_Configuration.ChannelType == E_Liquid_Detector)
    {
        // At list one liquid Detectors Detects Liquid
        if (ConnectedRTDsBitfield > 1)
        {
            // Liquid detection - Turn OFF Dripping Pneumatic Valve.
            //StoredPwmValues[3] =
            DOD_PWMOut2_Write(0);
            memset(No_Liquid_Timer, 0, sizeof(No_Liquid_Timer));
        }
        else
        {
            if (ApplicatorDripValveEnable)
            {
                //StoredPwmValues[3] =
                DOD_PWMOut2_Write(PWM_4_DRIP_VALVE);
            }
            else
            {
                //StoredPwmValues[3] =
                DOD_PWMOut2_Write(0);
            }
        }
    }
    else
    {
        //if (ConnectedRTDsBitfield ^ RequiredRTDsBitfield)	 // check if any of the sensors was enabled
        if ((RequiredRTDsBitfield & ConnectedRTDsBitfield) != RequiredRTDsBitfield)
        {
            /* Update  system warnings  */
            SystemErrorReg_Write(MISSING_RTD_ERR_BIT_NUM, ENABLE, _16BIT1);
        }
        else
        {
            /* Update  system warnings  */
            SystemErrorReg_Write(MISSING_RTD_ERR_BIT_NUM, DISABLE, _16BIT1);
        }
    }
}

/* [] END OF FILE */
