/*****************************************************************************
 * File Name: Analog_Outputs_Handler.h
 *
 * Version: 02.02
 *
 * Description:
 *   This file has the following tasks:
 *   1. handle the MUXing of the analog inputs to SAR2 which includes:
 *       a. The voltage across a current to voltage converting resistor,
 in order to measure the current in the SSR's.
 b. The voltage across the connector ID resistors
 in order to identify which connector was connected to the FEC and PSoC.
 *   2. Finding the peak value of the currents in the SSR's measured as described above.
 *
 * Note:
 *   voltages coding of connector ID's- TBD.
 *
 * Note:
 *
 *****************************************************************************/

/***************************************
 *    Includes
 ***************************************/

#include "main.h"
#include "Monitor_Module_Handler.h"
#include "Communications_Handler.h"
#include "System_Handler.h"
#include "Digital_IO_Module_Handler.h"
#include "DSP.h"
#include <string.h>

/***************************************
 *    Global Variables
 ***************************************/
/* Variable declarations for DMA . 
 *  These variables are defined as global variables to avoid "may be used before being set" warning
 *  issued by the PSoC 5 compilers  MDK/RVDS.In this case these variables are automatically initialized to zero */

uint8 SAR2_IDs_DMADone_flag;

uint8 SAR2_IDs_DataWriteEnable;

uint8 CS_Required;
uint8 CS_State;
uint8 CS_Prev_State;
uint8 CS_State_Complete[3];

uint16 MinCSLimit[2];
uint16 MaxCSLimit[2];

int16 ZeroLevelTaps[2][CS_ZERO_LEVEL_NO_OF_TAPS];
int16 ZeroLevel[2];
int16 PeaksResults[2];

uint8 Heat_Control_Counter;
uint8 CS_Pulsecounter[2];
int16 PeaksResultsBuffer[2][PEAK_MA_WIDTH];

int16 SAR2_IDs_Sample[NO_OF_TOTAL_SAR2_IDs_SAMPLES] =
{ 0 };
int16 SAR2_IDs_SampleLatch[NO_OF_TOTAL_SAR2_IDs_SAMPLES] =
{ 0 };

uint8 CableID_ViolationQualifier;

uint16 Bounds4ID[35] =
{ 88, 232, 345, 459, 576, 691, 804, 917, 1028, 1144, 1256, 1360, 1469, 1583, 1701, 1821, 1942, 2064, 2186, 2306, 2424,
        2540, 2653, 2762, 2876, 2991, 3110, 3229, 3350, 3468, 3580, 3697, 3833, 3969, 4096 };
uint32 FiltCountID[NUM_OF_IDs_SENS];
float Vsupply;

T_StoredCS4MMCU StoredCS4MMCU;

T_StoredIDs4MMCU StoredIDs4MMCU;

/*******************************************************************************
 * Function Name: Init_Monitor_Module()
 ********************************************************************************
 * Summary:
 *
 * Parameters:
 *   none.
 *
 * Return:
 *   none.
 *******************************************************************************/
void Init_Monitor_Module(void)
{
    Vsupply = 24;
    CS_Required = 0;
    Heat_Cmd_Counter = 0;
    CS_Always_OFF_Counter[0] = 0;
    CS_Always_OFF_Counter[1] = 0;

    CS_DAB_1_CS_ON_Counter = 0;
    CS_DAB_2_CS_ON_Counter = 0;

    memset(MinCSLimit, 2048, sizeof(MinCSLimit));
    memset(MaxCSLimit, 0, sizeof(MaxCSLimit));

    CS_State = CS_INITIAL_STATE;
    memset(CS_State_Complete, 0, sizeof(CS_State_Complete));
    memset(PeaksResultsBuffer, 0, sizeof(PeaksResultsBuffer));
    /* reset CS parameters */
    memset(ZeroLevel, 2048, sizeof(ZeroLevel));
    memset(ZeroLevelTaps, 0, sizeof(ZeroLevelTaps));

    memset(CS_Pulsecounter, 0, sizeof(CS_Pulsecounter));
    Heat_Control_Counter = 0;

    SAR2_Flwr_Start();
    /* Start the SAR2 */
    SAR2_Start();
    /* Disable the ADC ISR2 as it is not required */
    SAR2_IRQ_Disable();
    /* Start the IDs_DMA Interrupt module */
    ISR_SAR2_IDs_DMA_Start();
    Heat_Counter_isr_Start();
    /* Relocate the ISRs of the Monitor Module */
    Monitor_ISRs_Relocate();
    /* Initiate the DMA module */
    SAR2_IDs_DMA_Config();
    /* Lower the  DMADone flag */
    SAR2_IDs_DMADone_flag = 0;
    /* Reset the SAR2 Cable ID's data buffer */
    memset(SAR2_IDs_Sample, 0, sizeof(SAR2_IDs_Sample));

    /* Reset the stored current loop data for the MMCU */
    memset(&StoredCS4MMCU, 0, sizeof(StoredCS4MMCU));
    /* Reset the stored Cable ID's data for the MMCU */
    memset(&StoredIDs4MMCU, 0, sizeof(StoredIDs4MMCU));
    /* Allow writting data into SAR2_CS_SampleLatch */
    SAR2_IDs_DataWriteEnable = 1;
    /* Cable ID Qualifier */
    CableID_ViolationQualifier = 0;

    /* Start the SAR2 conversion */
    SAR2_soc_Enable();
}

/*******************************************************************************
 * Function Name:  SAR2_IDs_DMA_Config()
 ********************************************************************************
 *
 * Summary:
 *    Code generated by the DMA Wizard.
 *
 *   DMA_Config() performs following functions:
 *  1: Initializes the DMA channel
 *  2: Allocates TraCH0_ERRORnsfer Descriptors
 *  3: Configures the TD.
 *  4: Sets source and destination address for this TD.
 *  5: Initializes the TD.
 *  6: Enables the DMA channel.
 *
 * Parameters:
 *  None.
 *
 * Return:
 *  None.
 *
 *******************************************************************************/
void SAR2_IDs_DMA_Config()
{
    uint8 SAR2_IDs_DMA_Chan;
    uint8 SAR2_IDs_DMA_TD[1];
    // DMA Initialization - 2 byte per trigger.Each burst transfer needs a new request. 
    // Set upper source and destination address. //
    SAR2_IDs_DMA_Chan = SAR2_IDs_DMA_DmaInitialize(SAR2_IDs_DMA_BYTES_PER_BURST, SAR2_IDs_DMA_REQUEST_PER_BURST,
            HI16(SAR2_IDs_DMA_SRC_BASE), HI16(SAR2_IDs_DMA_DST_BASE));
    // Allocate TD //
    SAR2_IDs_DMA_TD[0] = CyDmaTdAllocate();
    // Destination address is incremented after each transaction and Term out generated after 
    // the specified no. of bytes are transferred to memory
    // Tranfer the specified number of samples and generate term out //
    CyDmaTdSetConfiguration(SAR2_IDs_DMA_TD[0], (sizeof(SAR2_IDs_Sample)), SAR2_IDs_DMA_TD[0],
            SAR2_IDs_DMA__TD_TERMOUT_EN | TD_INC_DST_ADR);

    // Set source and destination address //
    CyDmaTdSetAddress(SAR2_IDs_DMA_TD[0], LO16((uint32 )SAR2_SAR_WRK0_PTR), LO16((uint32 )SAR2_IDs_Sample));

    // Set the intial TD for the channel //
    CyDmaChSetInitialTd(SAR2_IDs_DMA_Chan, SAR2_IDs_DMA_TD[0]);
    // Enable the DMA channel //
    CyDmaChEnable(SAR2_IDs_DMA_Chan, 1);
}

/*******************************************************************************
 * Function Name: void Current_Sensors_Analysis(uint8 Src);
 ********************************************************************************
 * Summary:
 *
 * Parameters:
 *   none.
 *
 * Return:
 *   none.
 *******************************************************************************/
void Current_Sensors_Analysis(uint8 Src)
{
    //static uint8 m=0,n=0;
    int16 MeanCurrent;
    switch (CS_State)
    {
    ///////////////////
    // Initial State //
    ///////////////////
    case CS_INITIAL_STATE:
    {
        /* Find the interrupt source */
        switch (Src)
        {
        /* CS_DAB_1_Z_Data_Ready */
        case CS1_Z_DATA_READY:
        {
            if (!(CS_State_Complete[CS_INITIAL_STATE] & 0x01))
            {
                ZeroLevel[0] = mean(CS_DAB_1_Zero_Data, CS_DAB_1_SIZE_OF_ZERO_DATA_BUFFER);
                if (ZeroLevel[0] < CS_DAB_1_DETECT_THRESHOLD)
                {
                    /* CS is not Connected Warning */
                    CS_State = CS_DISCONNECT_STATE;
                }
                CS_DAB_1_Calibrate(ZeroLevel[0], CS_DAB_1_DETECT_THRESHOLD);
                CS_State_Complete[CS_INITIAL_STATE] |= 0x01;
                CS_DAB_1_CS_ON_Counter = 0;
                //memset(&PeaksResultsBuffer[0][0],0,PEAK_MA_WIDTH);
            }
            break;
        }

            /* CS_DAB_2_Z_Data_Ready */
        case CS2_Z_DATA_READY:
        {
            if (!(CS_State_Complete[CS_INITIAL_STATE] & 0x02))
            {
                ZeroLevel[1] = mean(CS_DAB_2_Zero_Data, CS_DAB_2_SIZE_OF_ZERO_DATA_BUFFER);
                if (ZeroLevel[1] < CS_DAB_2_DETECT_THRESHOLD)
                {
                    /* CS is not Connected Warning */
                    CS_State = CS_DISCONNECT_STATE;
                }
                CS_DAB_2_Calibrate(ZeroLevel[1], CS_DAB_2_DETECT_THRESHOLD);
                CS_State_Complete[CS_INITIAL_STATE] |= 0x02;
                CS_DAB_2_CS_ON_Counter = 0;
                //memset(&PeaksResultsBuffer[1][0],0,PEAK_MA_WIDTH);
            }
            break;
        }
        default:
        {
            CS_DAB_1_Calibrate(2048, CS_DAB_1_DETECT_THRESHOLD);
            CS_DAB_2_Calibrate(2048, CS_DAB_2_DETECT_THRESHOLD);
            CS_DAB_1_CS_ON_Counter = 0;
            CS_DAB_2_CS_ON_Counter = 0;
            break;
        }
        }

        if (CS_State_Complete[CS_INITIAL_STATE] == 0x03)
        {
            PBIT_Disable();
            Heat_Output_Enable();
            if (CS_Required)
            {
                CS_State = CS_CONNECT_STATE;
            }
            else
            {
                CS_State = CS_INITIAL_STATE;
                // maor: removed this error, to prevent the error from rising before starting heating.
//                if (GET_BOARD_TYPE == IBT_DRYER)
//                {
//                    SystemErrorReg_Write(MISSING_CURRENT_SENS_ERR_BIT_NUM, ENABLE, _16BIT2);
//                }
            }
            CS_State_Complete[CS_INITIAL_STATE] = 0;
        }
        break;
    }
        ///////////////////
        // Connect State //
        ///////////////////
    case CS_CONNECT_STATE:
    {
        /* Find the interrupt source */
        switch (Src)
        {
        /* CS_DAB_1_P_Data_Ready */
        case CS1_P_DATA_READY:
        {
            MeanCurrent = mean(CS_DAB_1_Peak_Data, CS_DAB_1_SIZE_OF_PEAKS_DATA_BUFFER);
            if (MeanCurrent < CS_DAB_1_DETECT_THRESHOLD)
            {
                /* CS is not Connected Warning */
                CS_State = CS_DISCONNECT_STATE;
            }
            else
            {
                Find_Current_Peaks(CS_DAB_1_Peak_Data, PeaksResults, CS_DAB_1_SIZE_OF_PEAKS_DATA_BUFFER, AVE_WIDTH,
                        ZeroLevel[0]);
                CS_Check_Current(0);
            }
            CS_Always_OFF_Counter[0] = 0;
            break;
        }
            /* CS_DAB_1_Z_Data_Ready */
        case CS1_Z_DATA_READY:
        {
            ZeroLevel[0] = mean(CS_DAB_1_Zero_Data, CS_DAB_1_SIZE_OF_ZERO_DATA_BUFFER);
            if (ZeroLevel[0] < CS_DAB_1_DETECT_THRESHOLD)
            {
                /* CS is not Connected Warning */
                CS_State = CS_DISCONNECT_STATE;
            }
            CS_DAB_1_Calibrate(ZeroLevel[0], CS_DAB_1_DETECT_THRESHOLD);
            break;
        }
            /* CS_DAB_2_P_Data_Ready */
        case CS2_P_DATA_READY:
        {
            MeanCurrent = mean(CS_DAB_2_Peak_Data, CS_DAB_2_SIZE_OF_PEAKS_DATA_BUFFER);
            if (MeanCurrent < CS_DAB_2_DETECT_THRESHOLD)
            {
                /* CS is not Connected Warning */
                CS_State = CS_DISCONNECT_STATE;
            }
            else
            {
                Find_Current_Peaks(CS_DAB_2_Peak_Data, PeaksResults, CS_DAB_2_SIZE_OF_PEAKS_DATA_BUFFER, AVE_WIDTH,
                        ZeroLevel[1]);
                CS_Check_Current(1);
            }
            CS_Always_OFF_Counter[1] = 0;
            break;
        }
            /* CS_DAB_2_Z_Data_Ready */
        case CS2_Z_DATA_READY:
        {
            ZeroLevel[1] = mean(CS_DAB_2_Zero_Data, CS_DAB_2_SIZE_OF_ZERO_DATA_BUFFER);
            if (ZeroLevel[1] < CS_DAB_2_DETECT_THRESHOLD)
            {
                /* CS is not Connected Warning */
                CS_State = CS_DISCONNECT_STATE;
            }
            CS_DAB_2_Calibrate(ZeroLevel[1], CS_DAB_2_DETECT_THRESHOLD);
            break;
        }
        default:
        {
            CS_DAB_1_Calibrate(2048, CS_DAB_1_DETECT_THRESHOLD);
            CS_DAB_2_Calibrate(2048, CS_DAB_2_DETECT_THRESHOLD);
            CS_State = CS_INITIAL_STATE;
            Heat_Output_Disable();
            PBIT_Enable();
            break;
        }
        }

        /* "Check for current always ON" error */
        if (CS_DAB_1_CS_ON_Counter > CS_NO_OF_FALSE_CURRENTS || CS_DAB_2_CS_ON_Counter > CS_NO_OF_FALSE_CURRENTS)
        {
            // if the PWM output is more than 50%, don't raise the SSR Always On error.
            if (CurrentPwmValues[0] < 50)
            {
                //Safety_Relay_TurnON();
                SystemErrorReg_Write(SSR_ALWAYS_ON_ERR_BIT_NUM, ENABLE, _16BIT2);
            }
        }
        /* "Check for current always OFF" warning */
        if ((CS_Always_OFF_Counter[0] > CS_NO_OF_CURRENTS_MISSES)
                || (CS_Always_OFF_Counter[1] > CS_NO_OF_CURRENTS_MISSES))
        {
            SystemWarningReg_Write(SSR_ALWAYS_OFF_WARN_BIT_NUM, ENABLE, _16BIT1);
            if ((CS_Always_OFF_Counter[0] > CS_NO_OF_CURRENTS_MISSES))
            {
                StoredCS4MMCU.Peak[0] = 0;
            }
            if (CS_Always_OFF_Counter[1] > CS_NO_OF_CURRENTS_MISSES)
            {
                StoredCS4MMCU.Peak[1] = 0;
            }
        }
        else
        {
            SystemWarningReg_Write(SSR_ALWAYS_OFF_WARN_BIT_NUM, DISABLE, _16BIT1);
        }
        CS_Prev_State = CS_CONNECT_STATE;
        break;
    }
        //////////////////////
        // Disconnect State //
        //////////////////////
    case CS_DISCONNECT_STATE:
    {
        static uint8 DisconnectEventCounter = 0;

        CS_DAB_1_CS_ON_Counter = 0;
        CS_DAB_2_CS_ON_Counter = 0;
        memset(&StoredCS4MMCU, 0, sizeof(StoredCS4MMCU));

        if (DisconnectEventCounter > 10)
        {
            SystemErrorReg_Write(MISSING_CURRENT_SENS_ERR_BIT_NUM, ENABLE, _16BIT1);
            SystemWarningReg_Write(SSR_ALWAYS_OFF_WARN_BIT_NUM, DISABLE, _16BIT1);
        }
        else
        {
            DisconnectEventCounter++;
        }

        /* Find the interrupt source */
        switch (Src)
        {
        /* CS_DAB_1_P_Data_Ready */
        case CS1_P_DATA_READY:
        {
            MeanCurrent = mean(CS_DAB_1_Peak_Data, CS_DAB_1_SIZE_OF_PEAKS_DATA_BUFFER);
            if (MeanCurrent > (2 * CS_DAB_1_DETECT_THRESHOLD))
            {
                CS_State_Complete[CS_DISCONNECT_STATE] |= 0x01;

            }
            break;
        }
            /* CS_DAB_1_Z_Data_Ready */
        case CS1_Z_DATA_READY:
        {
            MeanCurrent = mean(CS_DAB_1_Zero_Data, CS_DAB_1_SIZE_OF_ZERO_DATA_BUFFER);
            if (MeanCurrent > (2 * CS_DAB_1_DETECT_THRESHOLD))
            {
                CS_State_Complete[CS_DISCONNECT_STATE] |= 0x01;
            }
            break;
        }
            /* CS_DAB_2_P_Data_Ready */
        case CS2_P_DATA_READY:
        {
            MeanCurrent = mean(CS_DAB_2_Peak_Data, CS_DAB_2_SIZE_OF_PEAKS_DATA_BUFFER);
            if (MeanCurrent > (2 * CS_DAB_1_DETECT_THRESHOLD))
            {
                /* CS is not Connected Warning */
                CS_State_Complete[CS_DISCONNECT_STATE] |= 0x02;
            }
            break;
        }
            /* CS_DAB_2_Z_Data_Ready */
        case CS2_Z_DATA_READY:
        {
            MeanCurrent = mean(CS_DAB_2_Zero_Data, CS_DAB_2_SIZE_OF_ZERO_DATA_BUFFER);
            if (MeanCurrent > (2 * CS_DAB_1_DETECT_THRESHOLD))
            {
                CS_State_Complete[CS_DISCONNECT_STATE] |= 0x02;
            }
            break;
        }
        default:
        {
            CS_DAB_1_Calibrate(2048, CS_DAB_1_DETECT_THRESHOLD);
            CS_DAB_2_Calibrate(2048, CS_DAB_2_DETECT_THRESHOLD);
            CS_State_Complete[CS_DISCONNECT_STATE] = 0;
            DisconnectEventCounter = 0;
            CS_State = CS_INITIAL_STATE;
            Heat_Output_Disable();
            PBIT_Enable();
            break;
        }
        }
        if (CS_State_Complete[CS_DISCONNECT_STATE] == 0x03)
        {
            /* CS is Connected Warning */
            SystemErrorReg_Write(MISSING_CURRENT_SENS_ERR_BIT_NUM, DISABLE, _16BIT1);
            CS_State_Complete[CS_DISCONNECT_STATE] = 0;
            DisconnectEventCounter = 0;
            CS_State = CS_INITIAL_STATE;
            Heat_Output_Disable();
            PBIT_Enable();
        }
        break;
    }
        CS_Prev_State = CS_DISCONNECT_STATE;
    default:
    {
        SystemWarningReg_Write(SSR_ALWAYS_OFF_WARN_BIT_NUM, DISABLE, _16BIT1);
        CS_State = CS_INITIAL_STATE;
        CS_Prev_State = CS_INITIAL_STATE;
        Heat_Output_Disable();
        PBIT_Enable();
        break;
    }
    }
}

/****************************************************************************************************
 * Function Name: void Find_Current_Peaks(int16 * x, int16 * y, uint8 N, uint8 aw, int16 Zero_Level)
 *****************************************************************************************************
 * Summary:
 *
 * Parameters:
 *   none.
 *
 * Return:
 *   none.
 *******************************************************************************/
void Find_Current_Peaks(int16 * x, int16 * y, uint8 N, uint8 aw, int16 Zero_Level)
{
    int32 Sum;
    int32 Pos_Peak;
    int32 Neg_Peak;
    uint8 i;
    int8 j;
    /* Input protection */
    if (aw < 1)
    {
        aw = 1;
    }
    if (N < 1)
    {
        N = 1;
    }
    /* reseting peaks */
    Pos_Peak = aw * Zero_Level;
    Neg_Peak = aw * Zero_Level;

    for (i = aw; i < N; i++)
    {
        Sum = 0;

        for (j = i; j > i - aw; j--)
        {
            Sum += (int32) x[j];
        }

        if (Sum > Pos_Peak)
        {
            Pos_Peak = Sum;
        }

        if (Sum < Neg_Peak)
        {
            Neg_Peak = Sum;
        }
    }
    y[0] = (int16) (Pos_Peak / aw - Zero_Level);
    y[1] = (int16) ((int16) (Neg_Peak / aw) - Zero_Level);
}

/****************************************************************************************************
 * Function Name: uint8 Read_Counter(uint8 Prev_Count, uint8 Count);
 *****************************************************************************************************
 * Summary:
 *
 * Parameters:
 *   none.
 *
 * Return:
 *   none.
 *******************************************************************************/
uint8 Read_Counter(uint8 Prev_Count, uint8 Count)
{
    if (Prev_Count > Count)
    {
        Count = 0xFF - Prev_Count + Count;
        return (Count);
    }
    return (Count - Prev_Count);
}

/****************************************************************************************************
 * Function Name: void CS_Check_Current(uint8 CS_Indx);
 *****************************************************************************************************
 * Summary:
 *
 * Parameters:
 *   none.
 *
 * Return:
 *   none.
 *******************************************************************************/
void CS_Check_Current(uint8 CS_Indx)
{
    static uint8 m = 0, n = 0;

    int16 PeakDiff = PeaksResults[0] - PeaksResults[1];

    switch (CS_Indx)
    {
    case 0:
    {

        if (PeakDiff > 0) // Take the Positive peak.
        {
            PeaksResultsBuffer[0][m] = PeaksResults[0];
        }
        else	// Take the Negative peak.
        {
            PeaksResultsBuffer[0][m] = PeaksResults[1];
        }
        if (m < PEAK_MA_WIDTH)
        {
            StoredCS4MMCU.Peak[0] = mean(&PeaksResultsBuffer[0][0], PEAK_MA_WIDTH);
            m++;
        }
        else
        {
            m = 0;
        }

        /* Check if over current */
        if (StoredCS4MMCU.Peak[0] > 2048)	//MaxCSLimit[0])
        {
            SystemErrorReg_Write(SSR_OVER_CURRENT_ERR_BIT_NUM, ENABLE, _16BIT1);
            memset(PeaksResultsBuffer, 0, sizeof(PeaksResultsBuffer));
        }
        break;
    }
    case 1:
    {

        if (PeakDiff > 0) // Take the Positive peak.
        {
            PeaksResultsBuffer[1][n] = PeaksResults[0];
        }
        else	// Take the Negative peak.
        {
            PeaksResultsBuffer[1][n] = PeaksResults[1];
        }
        if (n < PEAK_MA_WIDTH)
        {
            StoredCS4MMCU.Peak[1] = mean(&PeaksResultsBuffer[1][0], PEAK_MA_WIDTH);
            n++;
        }
        else
        {
            n = 0;
        }

        /* Check if over current */
        if (StoredCS4MMCU.Peak[1] > 2048)	//MaxCSLimit[1])
        {
            SystemErrorReg_Write(SSR_OVER_CURRENT_ERR_BIT_NUM, ENABLE, _16BIT2);
            memset(PeaksResultsBuffer, 0, sizeof(PeaksResultsBuffer));
        }
        break;
    }
    default:
    {
        break;
    }
    }
    /* 5. Check the peak plarity */

}
/****************************************************************************************************
 * Function Name: uint8 Read_HCP_Counter(void)
 *****************************************************************************************************
 * Summary:
 *
 * Parameters:
 *   none.
 *
 * Return:
 *   none.
 *******************************************************************************/
uint8 Read_HCP_Counter(void)
{
    uint8 Count = Heat_Cmd_Counter;
    Heat_Cmd_Counter = 0;
    return (Count);
}
/*******************************************************************************
 * Function Name: Calc_Current_Loop()
 ********************************************************************************
 * Summary:
 *
 * Parameters:
 *   none.
 *
 * Return:
 *   none.
 *******************************************************************************/
void Calc_Cable_IDs(void)
{
    static int16 IDs_Data[NUM_OF_IDs_SENS][NUM_OF_SAR2_IDs_SAMPLES];

    uint8 i, j;

    /* Disable the write to SAR2_CS_SampleLatch */
    SAR2_IDs_DataWriteEnable = 0;
    /*  */
    for (j = 0; j < NUM_OF_IDs_SENS; j++)
    {
        for (i = 0; i < NUM_OF_SAR2_IDs_SAMPLES; i++)
        {
            IDs_Data[j][i] = (SAR2_IDs_SampleLatch[j + (NUM_OF_IDs_SENS * i)]);
        }
    }
    /* Enable the write to SAR2_CS_SampleLatch */
    SAR2_IDs_DataWriteEnable = 1;

    /* Calculate the mean value of the samples, convert to volts and store in StoredIDs4MMCU */
    for (i = 0; i < NUM_OF_IDs_SENS; i++)
    {
        FiltCountID[i] = (uint32) (mean(&(IDs_Data[i][0]), NUM_OF_SAR2_IDs_SAMPLES));
        if (FiltCountID[i] > 4095)
        {
            FiltCountID[i] = 4095;
        }

    }
    Cable_Count_To_ID();

    if ((StoredIDs4MMCU.ID[0] == StoredIDs4MMCU.ID[1]) && (StoredIDs4MMCU.ID[1] == StoredIDs4MMCU.ID[2])
            && (StoredIDs4MMCU.ID[2]))

    {
        if (!StoredIDs4MMCU.ID[0])
        {
            if (CableID_ViolationQualifier > CABLE_ID_MISSMATCH_QUALIFIER)
            {
                SystemErrorReg_Write(CABLES_ID_CONFLICT_ERR_BIT_NUM, ENABLE, _16BIT2);
                CableID_ViolationQualifier = 0;
            }
            CableID_ViolationQualifier++;
        }
        else
        {
            // CableID OK
            SystemErrorReg_Write(CABLES_ID_CONFLICT_ERR_BIT_NUM, DISABLE, _16BIT2);
            CableID_ViolationQualifier = 0;
        }
    }
    else
    {
        CableID_ViolationQualifier++;
        if (CableID_ViolationQualifier > CABLE_ID_MISSMATCH_QUALIFIER)
        {
            // CableID Violation
            if(GET_BOARD_TYPE == E_PsocPrimaryFunction_HwValidation)
            {
                SystemErrorReg_Write(CABLES_ID_CONFLICT_ERR_BIT_NUM, DISABLE, _16BIT2);
            }
            else
            {
                SystemErrorReg_Write(CABLES_ID_CONFLICT_ERR_BIT_NUM, ENABLE, _16BIT2);
            }
            CableID_ViolationQualifier = 0;
        }
    }
}

/*******************************************************************************
 * Function Name: void Cable_Count_To_ID(void)
 ********************************************************************************
 * Summary:
 *
 * Parameters:
 *   none.
 *
 * Return:
 *   none.
 *******************************************************************************/
void Cable_Count_To_ID(void)
{
    uint8 k, i;
    float VsRatio = 1;
    if (Vsupply != 0)
        VsRatio = 24 / Vsupply;

    for (i = 0; i < NUM_OF_IDs_SENS; i++)
    {
        for (k = 0; k < 35; k++)
        {
            if ((uint16) (VsRatio * FiltCountID[i]) <= Bounds4ID[k])
            {
                StoredIDs4MMCU.ID[i] = k;
                break;
            }
        }
    }
}

/* [] END OF FILE */
