/*****************************************************************************
 * File Name: Temperature_Module_Handler.c
 *
 * Version: 02.02
 *
 * Description:
 *   The file is divided in 2:
 *   1. PT100 Inputs which responsible for:
 *      a. The MUXing of the voltages across 4 PT100's and 1 calibration resistor when
 *         current is flowing through them and when not. the "non-current" voltages are used
 *         for 1/f noise reduction.
 *      b. Conversion of measured voltage to temperature.
 *   2. PWM outputs with controllable duty cycle.
 *
 * Note:
 *   the PWM outputs are hard ANDed with the Safet_Relay input.
 *
 ********************************************************************************/

/***************************************
 * Includes
 ***************************************/
#include "Temperature_Module_Handler.h"
#include "Digital_IO_Module_Handler.h"
#include "System_Handler.h"
#include "main.h"
#include "DSP.h"
#include <string.h>

/***************************************
 *    Global Variables
 ***************************************/
/* Variable declarations for DMA . 
 * These variables are defined as global variables to avoid "may be used before being set" warning
 * issued by the PSoC 5 compilers  MDK/RVDS.In this case these variables are automatically initialized to zero */

uint8 DSM_DMA_Chan;
uint8 DSM_DMADone_flag;
uint8 DSMDataWriteEnable;

uint8 CalcTempr_InitVar;
uint8 WarnBitfield[4] = { 0x02, 0x08, 0x20, 0x80 };
uint8 ErrorBitfield[4] = { 0x01, 0x04, 0x10, 0x40 };
uint8 Ind2Bit_5[5] = {0x01, 0x02, 0x04, 0x08, 0x10};

uint8 RequiredRTDsBitfield;
uint8 ConnectedRTDsBitfield;

float TempUpLimit[NUM_OF_TEMP_SENS] =
{ 0, 0, 0, 0 };

uint16 Temperature1_Monitor;
uint16 Temperature2_Monitor;
uint16 Temperature3_Monitor;
uint16 Temperature4_Monitor;

int16 DSM_Sample[NUM_OF_DSM_SAMPLES] = { 0 };
int16 DSM_SampleLatch[NUM_OF_DSM_SAMPLES] = { 0 };

T_StoredTemps4MMCU StoredTemps4MMCU;

/*******************************************************************************
 ********************  P T 1 0 0    I N P T S   *********************************
 ********************************************************************************/

/*******************************************************************************
 * Function Name:  Init_Temperature_Module
 ********************************************************************************
 *
 * Summary:
 *    InitTempSense initiate the RTD temperature sensing modules and system.
 *
 * Parameters:
 *   None.
 *
 * Return:
 *   None.
 *******************************************************************************/
void Init_Temperature_Module(void)
{
    /* raise a flag to initiate the temperature calculation arrays */
    CalcTempr_InitVar = 0;
    /* Start the current source for RTD's excitement */
    IDAC_Start();
    /* Start the DSM Sequencer */
    DSM_Sequencer_Start();
    /* Delay between Mux switch and SOC */
    DSM_Sequencer_SOC_Delay_SetPeriod(199);
    /* Start the Delta Sigma Modulation (DSM) ADC for the RTD's Measurements */
    DSM_Start();
    /* Disable the ADC ISR as it is not required */
    DSM_IRQ_Disable();
    /* Start the DMA Interrupt module */
    ISR_DSM_DMA_Start();
    /* Relocate the ISRs of the Temperature Module */
    Temperature_ISRs_Relocate();
    /* Initiate the DMA module */
    DSM_DMA_Config();
    /* Lower the  DMADone flag */
    DSM_DMADone_flag = 0;
    /*Initiate RequiredRTDsBitfield */
	RequiredRTDsBitfield = 0x01;
    ConnectedRTDsBitfield = 0x00;
    RTD_Configuration.ChannelType = E_PT100;

    /*Initiate Temperature reading */
    memset(StoredTemps4MMCU.temperature, 0, sizeof(StoredTemps4MMCU.temperature));
    StoredTemps4MMCU.statusBits = 0;
    /* Allow writing data into DSM_SampleLatch */
    DSMDataWriteEnable = 1;
}

/*******************************************************************************
 * Function Name:  DSM_DMA_Config
 ********************************************************************************
 *
 * Summary:
 *    Code generated by the DMA Wizard.
 *
 *   DMA_Config() performs following functions:
 *  1: Initializes the DMA channel
 *  2: Allocates TraCH0_ERRORnsfer Descriptors
 *  3: Configures the TD.
 *  4: Sets source and destination address for this TD.
 *  5: Initializes the TD.
 *  6: Enables the DMA channel.
 *
 * Parameters:
 *  None.
 *
 * Return:
 *  None.
 *
 *******************************************************************************/
void DSM_DMA_Config()
{
    uint8 DSM_DMA_TD[1];
    /* DMA Initialization - 2 byte per trigger.Each burst transfer needs a new request. 
     * Set upper source and destination address. */
    DSM_DMA_Chan = DSM_DMA_DmaInitialize(DSM_DMA_BYTES_PER_BURST, DSM_DMA_REQUEST_PER_BURST, HI16(DSM_DMA_SRC_BASE),
            HI16(DSM_DMA_DST_BASE));
    /* Allocate TD */
    DSM_DMA_TD[0] = CyDmaTdAllocate();
    /* Destination address is incremented after each transaction and Term out generated after 
     * the specified no. of bytes are transferred to memory
     * Transfer the specified number of samples and generate term out */
    CyDmaTdSetConfiguration(DSM_DMA_TD[0], (sizeof(DSM_Sample)), DSM_DMA_TD[0],
            DSM_DMA__TD_TERMOUT_EN | TD_INC_DST_ADR);

    /* Set source and destination address */
    CyDmaTdSetAddress(DSM_DMA_TD[0], LO16((uint32) DSM_DEC_SAMP_PTR), LO16((uint32) DSM_Sample));
    /* Set the initial TD for the channel */
    CyDmaChSetInitialTd(DSM_DMA_Chan, DSM_DMA_TD[0]);
    /* Enable the DMA channel */
    CyDmaChEnable(DSM_DMA_Chan, 1);
}

/***********************************
 * Function Name:  Calc_Temperature
 ************************************
 *
 * Summary:
 *   Calc_Temperature will measure the temperatures with the RTS sensors
 *
 * Remarks:
 *   See "Temp_Sense_Handler.h" for algorithm details.
 *
 * Parameters:
 *   none.
 *
 * Return:
 *   none.
 *
 *******************************************************************************/
void Calc_Temperature(void)
{
    static int32 FiltNoOffset_DSM_Sample[NUM_OF_TEMP_SENS + 1][2];
    static int32 NoOffset_DSM_Sample[NUM_OF_TEMP_SENS + 1];
    static int16 Quik_NoOffset_DSM_Sample[NUM_OF_TEMP_SENS + 1];
    static int16 NoOffset_DSM_Sample_Buffer[(NUM_OF_TEMP_SENS + 1)][(TEMPTR_MED_FILT_WIDTH)];
	static uint8 n = 1;
	static uint8 MedIndx = TEMPTR_MED_FILT_WIDTH;
    int16 Temp_NoOffset_DSM_Sample[TEMPTR_MED_FILT_WIDTH];
    memset(Temp_NoOffset_DSM_Sample, 0, sizeof(Temp_NoOffset_DSM_Sample));
    uint8 i;
	
    uint8 DSM_Samle_Indx_Pair;
    DSM_Samle_Indx_Pair = 0;

    float RTD_Resistance;

	
    if (!CalcTempr_InitVar)
    {
        CalcTempr_InitVar++;
        memset(FiltNoOffset_DSM_Sample, 0, sizeof(FiltNoOffset_DSM_Sample));
        memset(NoOffset_DSM_Sample, 0, sizeof(NoOffset_DSM_Sample));
        memset(Quik_NoOffset_DSM_Sample, 0, sizeof(Quik_NoOffset_DSM_Sample));
        memset(NoOffset_DSM_Sample_Buffer, 0, sizeof(NoOffset_DSM_Sample_Buffer));
		MedIndx = TEMPTR_MED_FILT_WIDTH;
    }

    /* Quick Data acquire */
    //////////////////////
    /* Disable the write to DSM_SampleLatch */
    DSMDataWriteEnable = 0;
	
	/* Start of 1/f Noise reduction */
    for (i = 0; i < NUM_OF_TEMP_SENS + 1; i++)
    {
        Quik_NoOffset_DSM_Sample[i] = (DSM_SampleLatch[DSM_Samle_Indx_Pair + 1] - DSM_SampleLatch[DSM_Samle_Indx_Pair]);
        /* increase the DSM_SampleLatch index pair */
        DSM_Samle_Indx_Pair += 2;
        /* End of 1/f Noise reduction */
    }
    /* Enable the write to DSM_SampleLatch */
    DSMDataWriteEnable = 1;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/* increasing the index for median filter for all channels together */
	MedIndx = CYC_INC_INDX(MedIndx,TEMPTR_MED_FILT_WIDTH);
    /* DSM DSP for calibrating resistor and all temperature sensor*/
    for (i = 0; i < NUM_OF_TEMP_SENS + 1; i++)
    {
        //----------------------------------------------------------------------------------------------------------------------
        /* Fill Median filter buffer */
		NoOffset_DSM_Sample_Buffer[i][MedIndx] = Quik_NoOffset_DSM_Sample[i];
        // Create a copy of the buffer
        memcpy(Temp_NoOffset_DSM_Sample, &NoOffset_DSM_Sample_Buffer[i][0], sizeof(Temp_NoOffset_DSM_Sample));
		
        // sort the copy of the median filter buffer and determine it's median value.
        NoOffset_DSM_Sample[i] = (int32) Med_Filter(Temp_NoOffset_DSM_Sample, TEMPTR_MED_FILT_WIDTH);
        // Data is ready in NoOffset_DSM_Sample.
        /* End of Median filter */
        //----------------------------------------------------------------------------------------------------------------------
        //----------------------------------------------------------------------------------------------------------------------
        /* Start of Single Pole IIR low-pass filtering the NoOffset_DSM_Sample */
		FiltNoOffset_DSM_Sample[i][n] = IIR_LPF_sp(NoOffset_DSM_Sample[i], &FiltNoOffset_DSM_Sample[i][n-1], TEMP_FILT_NUME);
		/* End of IIR_LPF_sp */
		
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////	
		// if not a calibration resistor Channel
        if (i)
        {
            /* Start of temperatures calculation */
            /*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
            /*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
            /*                            		 		D O   N O T   E D I T   T H O S E   L I N E S ! ! !                               	  */
            /*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
            /**/RTD_Resistance = (float) (FiltNoOffset_DSM_Sample[i][n] * CAL_REF_RESISTOR)
                    / FiltNoOffset_DSM_Sample[0][n]; /**/
            /**/StoredTemps4MMCU.temperature[(i - 1)] = ((float) RTD_GetTemperature((RTD_Resistance * 1000)))
                    / 100.00 + TEMPERATURE_OFFSET; /**/
            /*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
        }					
    }
}

/* [] END OF FILE */
